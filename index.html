<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="description"
        content="A AAA-quality modern arcade snake game with neon aesthetics and 60FPS performance.">
    <!-- Updated CSP to allow Firebase and Google Auth -->
    <meta http-equiv="Content-Security-Policy"
        content="default-src 'self' 'unsafe-inline' https:; img-src 'self' data: https:; font-src https://fonts.gstatic.com; script-src 'self' 'unsafe-inline' https://www.googletagmanager.com https://www.gstatic.com https://apis.google.com;">
    <title>NEON SNAKE | Cloud Edition</title>

    <!-- Google Services: Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@700&display=swap"
        rel="stylesheet">

    <!-- Google Services: Firebase Web SDK (Compat) -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-analytics-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-remote-config-compat.js"></script>

    <!-- Google Services: Analytics Stub -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-XXXXX-Y"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag() { dataLayer.push(arguments); }
        gtag('js', new Date());
        gtag('config', 'UA-XXXXX-Y');
    </script>

    <style>
        :root {
            --color-bg: #050505;
            --color-primary: #00ffff;
            /* Cyan */
            --color-secondary: #ff00ff;
            /* Magenta */
            --color-accent: #ffd700;
            /* Gold */
            --color-danger: #ff0040;
            /* Red */
            --color-success: #00ff00;
            --glass-bg: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --font-main: 'Inter', sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--color-bg);
            background-image:
                linear-gradient(rgba(0, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(0, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            color: white;
            font-family: var(--font-main);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            box-shadow: 0 0 100px rgba(0, 255, 255, 0.1);
            border-radius: 4px;
            overflow: hidden;
        }

        canvas {
            display: block;
            background: #000;
        }

        /* UI Overlays */
        .ui-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(5, 5, 5, 0.85);
            backdrop-filter: blur(10px);
            z-index: 10;
            transition: opacity 0.5s ease;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }

        h1 {
            font-size: 4rem;
            margin: 0 0 2rem 0;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            color: white;
            text-shadow:
                0 0 10px var(--color-primary),
                0 0 20px var(--color-primary),
                0 0 40px var(--color-primary);
            animation: pulse-glow 2s infinite ease-in-out;
        }

        .input-group {
            margin-bottom: 2rem;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        input[type="text"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--glass-border);
            padding: 1rem 2rem;
            font-size: 1.5rem;
            color: white;
            border-radius: 50px;
            text-align: center;
            font-family: var(--font-mono);
            outline: none;
            transition: all 0.3s;
            width: 300px;
        }

        .difficulty-cards {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 3rem;
        }

        .card {
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            padding: 1.5rem;
            border-radius: 1rem;
            width: 200px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
        }

        .card:hover,
        .card.selected {
            transform: translateY(-5px) scale(1.05);
            background: rgba(255, 255, 255, 0.1);
        }

        .card.selected {
            border-color: var(--color-primary);
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
        }

        .card h3 {
            margin: 0 0 0.5rem 0;
            font-family: var(--font-mono);
            color: var(--color-primary);
        }

        .btn-start {
            background: linear-gradient(45deg, var(--color-primary), var(--color-secondary));
            border: none;
            padding: 1rem 4rem;
            font-size: 1.5rem;
            color: black;
            font-weight: 900;
            border-radius: 50px;
            cursor: pointer;
            text-transform: uppercase;
            transition: all 0.3s;
            opacity: 0.5;
            pointer-events: none;
        }

        .btn-start.active {
            opacity: 1;
            pointer-events: all;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.5);
        }

        .btn-start:hover {
            transform: scale(1.1);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.8);
        }

        /* Google Login Button */
        .btn-google {
            background: white;
            color: #444;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: bold;
            font-family: var(--font-main);
            cursor: pointer;
            transition: 0.2s;
            margin-bottom: 1rem;
        }

        .btn-google:hover {
            background: #f1f1f1;
        }

        .google-icon {
            width: 18px;
            height: 18px;
        }

        /* User Profile Badge */
        #user-profile {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 5px 15px;
            border-radius: 20px;
            display: none;
        }

        #user-profile.visible {
            display: flex;
        }

        #user-avatar {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #ccc;
        }

        /* Ad Overlay */
        #ad-overlay {
            background: black;
            z-index: 100;
            flex-direction: column;
        }

        .ad-content {
            border: 2px solid white;
            padding: 2rem;
            text-align: center;
            max-width: 400px;
        }

        .ad-timer {
            font-size: 3rem;
            font-weight: bold;
            color: yellow;
            margin: 1rem 0;
        }

        .btn-ad {
            background: #ffaa00;
            color: black;
            border: none;
            padding: 0.8rem 2rem;
            font-weight: bold;
            font-family: var(--font-mono);
            cursor: pointer;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 0 auto;
        }

        .btn-ad:hover {
            filter: brightness(1.2);
        }

        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            right: 20px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            font-family: var(--font-mono);
            font-size: 1.2rem;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
        }

        .hud-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .glow-text-cyan {
            color: var(--color-primary);
            text-shadow: 0 0 10px var(--color-primary);
        }

        .glow-text-magenta {
            color: var(--color-secondary);
            text-shadow: 0 0 10px var(--color-secondary);
        }

        .glow-text-gold {
            color: var(--color-accent);
            text-shadow: 0 0 10px var(--color-accent);
        }

        /* Notifications */
        #notification-overlay {
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: 900;
            color: var(--color-primary);
            text-shadow: 0 0 30px var(--color-primary);
            opacity: 0;
            transform: scale(0.5);
        }

        #notification-overlay.active {
            animation: notif-pop 2s forwards;
        }

        @keyframes notif-pop {
            0% {
                opacity: 0;
                transform: scale(0.5);
            }

            20% {
                opacity: 1;
                transform: scale(1.2);
            }

            40% {
                transform: scale(1.0);
            }

            80% {
                opacity: 1;
            }

            100% {
                opacity: 0;
                transform: scale(1.1);
            }
        }

        @keyframes pulse-glow {

            0%,
            100% {
                text-shadow: 0 0 20px var(--color-primary);
            }

            50% {
                text-shadow: 0 0 10px var(--color-secondary);
            }
        }

        /* Leaderboard Table */
        table {
            width: 100%;
            border-collapse: collapse;
            font-family: var(--font-mono);
            margin-top: 1rem;
        }

        th,
        td {
            padding: 0.5rem;
            text-align: left;
            border-bottom: 1px solid var(--glass-border);
        }

        th {
            color: var(--color-primary);
        }

        .highlight-row {
            color: var(--color-accent);
            font-weight: bold;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 150px;
            height: 150px;
            display: none;
            /* Active on touch only */
            opacity: 0.4;
            pointer-events: all;
            z-index: 5;
        }

        @media (max-width: 768px) {
            .difficulty-cards {
                flex-direction: column;
                width: 80%;
            }

            .card {
                width: 100%;
            }

            h1 {
                font-size: 2.5rem;
            }
        }
    </style>
</head>

<body>

    <div id="game-container">
        <canvas id="gameCanvas" aria-label="Game Board" role="img"></canvas>

        <!-- HUD Layer -->
        <div id="hud">
            <div class="hud-left">
                <div class="hud-item"><span class="glow-text-cyan">SCORE:</span> <span id="scoreVal">0</span></div>
                <div class="hud-item"><span class="glow-text-magenta">LEVEL:</span> <span id="levelVal">1</span></div>
            </div>
            <div class="hud-right">
                <div id="user-profile">
                    <img id="user-avatar" src="" alt="Avatar">
                    <span id="user-name">Guest</span>
                </div>
                <div class="hud-item"><span id="speedVal" class="glow-text-gold"></span></div>
            </div>
        </div>

        <!-- Notifications -->
        <div id="notification-overlay" class="ui-screen bg-transparent"></div>

        <!-- Ad Overlay -->
        <div id="ad-overlay" class="ui-screen hidden">
            <div class="ad-content">
                <h2>WORD FROM OUR SPONSORS</h2>
                <p>Simulating Ad Loading...</p>
                <div class="ad-timer" id="adTimer">5</div>
                <p style="font-size: 0.8rem; color: #888;">[AdMob Rewarded Video Placeholder]</p>
            </div>
        </div>

        <!-- Start Screen -->
        <div id="start-screen" class="ui-screen">
            <h1>Neon Snake</h1>
            <p style="color: #aaa; margin-top: -1.5rem; margin-bottom: 2rem;">CLOUD EDITION</p>

            <div class="input-group">
                <button id="btnLogin" class="btn-google">
                    <svg class="google-icon" viewBox="0 0 24 24">
                        <path
                            d="M22.56 12.25c0-.78-.07-1.53-.2-2.25H12v4.26h5.92c-.26 1.37-1.04 2.53-2.21 3.31v2.77h3.57c2.08-1.92 3.28-4.74 3.28-8.09z"
                            fill="#4285F4" />
                        <path
                            d="M12 23c2.97 0 5.46-.98 7.28-2.66l-3.57-2.77c-.98.66-2.23 1.06-3.71 1.06-2.86 0-5.29-1.93-6.16-4.53H2.18v2.84C3.99 20.53 7.7 23 12 23z"
                            fill="#34A853" />
                        <path
                            d="M5.84 14.11c-.22-.66-.35-1.36-.35-2.11s.13-1.45.35-2.11V7.05H2.18C1.43 8.55 1 10.22 1 12s.43 3.45 1.18 4.95l3.66-2.84z"
                            fill="#FBBC05" />
                        <path
                            d="M12 5.38c1.62 0 3.06.56 4.21 1.64l3.15-3.15C17.45 2.09 14.97 1 12 1 7.7 1 3.99 3.47 2.18 7.05l3.66 2.84c.87-2.6 3.3-4.51 6.16-4.51z"
                            fill="#EA4335" />
                    </svg>
                    Sign in with Google
                </button>
                <input type="text" id="playerNameInput" placeholder="ENTER NAME" maxlength="15"
                    aria-label="Enter Player Name">
            </div>

            <div class="difficulty-cards" role="radiogroup" aria-label="Select Difficulty">
                <div class="card" data-diff="BEGINNER" role="radio" tabindex="0">
                    <h3>BEGINNER</h3>
                    <p>Speed: Slow<br>x1.0 Score</p>
                </div>
                <div class="card" data-diff="CHALLENGE" role="radio" tabindex="0">
                    <h3>CHALLENGE</h3>
                    <p>Speed: Medium<br>x1.5 Score<br>2 Obstacles</p>
                </div>
                <div class="card" data-diff="EXPERT" role="radio" tabindex="0">
                    <h3>EXPERT</h3>
                    <p>Speed: Fast<br>x2.5 Score<br>5 Obstacles</p>
                </div>
            </div>

            <button id="btnStart" class="btn-start">START GAME</button>
        </div>

        <!-- Game Over Screen -->
        <div id="game-over-screen" class="ui-screen hidden">
            <h1>GAME OVER</h1>
            <h2 class="glow-text-gold">SCORE: <span id="finalScore">0</span></h2>

            <div style="margin-bottom: 1rem;">
                <button id="btnWatchAd" class="btn-ad">
                    üì∫ WATCH AD TO REVIVE (+1 LIFE)
                </button>
            </div>

            <div style="background: rgba(0,0,0,0.5); padding: 1rem; border-radius: 8px; width: 80%; max-width: 400px;">
                <div style="display:flex; justify-content:space-between; align-items:center;">
                    <h3 style="color: var(--color-primary); margin:0;" id="lbTitle">LOCAL LEGENDS</h3>
                    <small style="color:#888; cursor:pointer;" id="lbToggle">Switch to Global üåê</small>
                </div>
                <table id="leaderboardTable">
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>NAME</th>
                            <th>SCORE</th>
                            <th>LVL</th>
                        </tr>
                    </thead>
                    <tbody><!-- JS Populated --></tbody>
                </table>
            </div>
            <div style="margin-top: 1rem; display: flex; gap: 1rem;">
                <button id="btnRestart" class="btn-start active" style="padding: 0.5rem 2rem;">RETRY</button>
                <button id="btnMenu" class="btn-start active"
                    style="padding: 0.5rem 2rem; filter: hue-rotate(90deg);">MENU</button>
            </div>
        </div>

        <!-- Mobile Controls Overlay -->
        <div id="mobile-controls"></div>
    </div>

    <script>
        /**
         * AAA MODERN SNAKE - CLOUD EDITION
         * Features: Firebase Auth, Firestore Leaderboards, AdMob Simulation
         */

        // --- FIREBASE CONTROLLER ---
        class CloudService {
            constructor() {
                // REPLACE WITH YOUR FIREBASE CONFIG
                // In a real app, these are environment variables.
                // For this demo, we use a placeholder config that will fail gracefully to LocalStorage.
                const firebaseConfig = {
                    apiKey: "YOUR_API_KEY",
                    authDomain: "your-project.firebaseapp.com",
                    projectId: "your-project",
                    storageBucket: "your-project.appspot.com",
                    messagingSenderId: "000000000",
                    appId: "1:00000000:web:00000000",
                    measurementId: "G-XXXXXX"
                };

                this.enabled = false;
                this.user = null;

                try {
                    if (firebase.app.length === 0) {
                        firebase.initializeApp(firebaseConfig);
                        this.db = firebase.firestore();
                        this.auth = firebase.auth();
                        this.analytics = firebase.analytics();
                        this.remoteConfig = firebase.remoteConfig();
                        this.enabled = true;
                        this.setupAuthListener();
                        console.log("Firebase Initialized");
                    }
                } catch (e) {
                    console.warn("Firebase Init Failed (Expected without Keys): using Local Storage");
                    this.enabled = false;
                }
            }

            setupAuthListener() {
                if (!this.enabled) return;
                this.auth.onAuthStateChanged(user => {
                    this.user = user;
                    updateProfileUI(user);
                });
            }

            async signIn() {
                if (!this.enabled) { alert("Add Firebase Keys to Enable Cloud Features!"); return; }
                const provider = new firebase.auth.GoogleAuthProvider();
                try {
                    await this.auth.signInWithPopup(provider);
                } catch (e) { console.error(e); }
            }

            async saveScore(name, score, level) {
                if (this.enabled && this.user) {
                    // Cloud Save
                    try {
                        await this.db.collection('leaderboard').add({
                            name: this.user.displayName || name,
                            uid: this.user.uid,
                            photoURL: this.user.photoURL,
                            score,
                            level,
                            date: firebase.firestore.FieldValue.serverTimestamp()
                        });
                    } catch (e) { console.error("Cloud Save Failed", e); }
                }
                // Always save local backup
                saveLocalScore(name, score, level);
            }

            async getGlobalLeaderboard() {
                if (!this.enabled) return [];
                try {
                    const snap = await this.db.collection('leaderboard')
                        .orderBy('score', 'desc')
                        .limit(10)
                        .get();
                    return snap.docs.map(d => d.data());
                } catch (e) {
                    return [];
                }
            }

            async fetchConfig() {
                if (!this.enabled) return null;
                try {
                    await this.remoteConfig.fetchAndActivate();
                    return {
                        baseSpeed: this.remoteConfig.getValue('base_speed').asNumber(),
                        spawnRate: this.remoteConfig.getValue('spawn_rate').asNumber()
                    };
                } catch (e) { return null; }
            }
        }

        // --- ADMOB SIMULATION ---
        class AdController {
            constructor(game) {
                this.game = game;
                this.overlay = document.getElementById('ad-overlay');
                this.timerEl = document.getElementById('adTimer');
                this.reviveUsed = false;
            }

            canWatchAd() {
                return !this.reviveUsed;
            }

            showRewardedAd(onReward) {
                this.overlay.classList.remove('hidden');
                let timeLeft = 5;
                this.timerEl.innerText = timeLeft;

                const interval = setInterval(() => {
                    timeLeft--;
                    this.timerEl.innerText = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(interval);
                        this.overlay.classList.add('hidden');
                        this.reviveUsed = true;
                        document.getElementById('btnWatchAd').style.display = 'none';
                        onReward();
                    }
                }, 1000);
            }
        }

        // --- CONFIGURATION & CONSTANTS ---
        const CONFIG = {
            GRID_SIZE: 20,
            COLORS: {
                HEAD: '#ffffff',
                BODY_START: '#00ffff',
                BODY_END: '#ff00ff',
                COIN: '#ffd700',
                DIAMOND: '#00bfff',
                OBSTACLE: '#ff0040',
                GRID: '#111111'
            },
            AUDIO: {
                COIN: { type: 'sine', freqStart: 800, freqEnd: 1200, dur: 0.15 },
                DIAMOND: { type: 'triangle', freq: 600, dur: 0.2 },
                DEATH: { type: 'noise', dur: 0.6 }
            },
            DIFFICULTY: {
                BEGINNER: { speed: 100, mult: 1.0, obst: 0 },
                CHALLENGE: { speed: 75, mult: 1.5, obst: 2 },
                EXPERT: { speed: 50, mult: 2.5, obst: 5 }
            }
        };

        // --- AUDIO SYSTEM (Web Audio API) ---
        class AudioController {
            constructor() {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.5;
                this.masterGain.connect(this.ctx.destination);
            }

            playTone(type, startF, endF, duration, waveType = 'sine') {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = waveType;
                osc.frequency.setValueAtTime(startF, this.ctx.currentTime);
                if (endF) osc.frequency.linearRampToValueAtTime(endF, this.ctx.currentTime + duration);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.masterGain);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            }

            playNoise(duration) {
                if (this.ctx.state === 'suspended') this.ctx.resume();
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.value = 200;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(noiseFilter);
                noiseFilter.connect(gain);
                gain.connect(this.masterGain);
                noise.start();
            }

            playLevelUp() {
                const now = this.ctx.currentTime;
                [523.25, 659.25, 783.99].forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    osc.frequency.value = freq;
                    gain.gain.setValueAtTime(0.3, now + i * 0.2);
                    gain.gain.linearRampToValueAtTime(0, now + i * 0.2 + 0.3);
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    osc.start(now + i * 0.2);
                    osc.stop(now + i * 0.2 + 0.4);
                });
            }
        }

        // --- PARTICLE SYSTEM ---
        class ParticleSystem {
            constructor(ctx) {
                this.ctx = ctx;
                this.pool = [];
                this.active = [];
                for (let i = 0; i < 300; i++) this.pool.push({ x: 0, y: 0, vx: 0, vy: 0, life: 0, color: '#fff', size: 0 });
            }

            emit(x, y, color, count = 12) {
                for (let i = 0; i < count; i++) {
                    if (this.pool.length === 0) break;
                    const p = this.pool.pop();
                    p.x = x; p.y = y;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 4 + 2;
                    p.vx = Math.cos(angle) * speed;
                    p.vy = Math.sin(angle) * speed;
                    p.life = 1.0;
                    p.color = color;
                    p.size = Math.random() * 4 + 2;
                    this.active.push(p);
                }
            }

            update() {
                for (let i = this.active.length - 1; i >= 0; i--) {
                    const p = this.active[i];
                    p.x += p.vx; p.y += p.vy; p.vy += 0.2; p.life -= 0.02;
                    if (p.life <= 0) {
                        this.pool.push(p);
                        this.active.splice(i, 1);
                    }
                }
            }

            draw() {
                this.active.forEach(p => {
                    this.ctx.globalAlpha = p.life;
                    this.ctx.fillStyle = p.color;
                    this.ctx.beginPath();
                    this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
                this.ctx.globalAlpha = 1.0;
            }
        }

        // --- GAME ENGINE ---
        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });
                this.audio = new AudioController();
                this.particles = new ParticleSystem(this.ctx);
                this.cloud = new CloudService();
                this.adManager = new AdController(this);

                this.state = 'MENU';
                this.lastTime = 0;
                this.accumTime = 0;
                this.tickRate = 0;
                this.score = 0;
                this.level = 1;
                this.coinsCollected = 0;
                this.playerName = '';
                this.difficulty = null;

                this.snake = [];
                this.direction = { x: 1, y: 0 };
                this.inputQueue = [];
                this.items = [];

                this.resize();
                window.addEventListener('resize', () => this.resize());
                this.setupInput();
                requestAnimationFrame(t => this.loop(t));
            }

            resize() {
                const size = Math.min(window.innerWidth, window.innerHeight) * 0.95;
                this.canvas.width = size;
                this.canvas.height = size;
                this.cellSize = size / CONFIG.GRID_SIZE;
            }

            setupInput() {
                const handleKey = (e) => {
                    if (this.state !== 'PLAYING') return;
                    const keyMap = { 'ArrowUp': { x: 0, y: -1 }, 'w': { x: 0, y: -1 }, 'ArrowDown': { x: 0, y: 1 }, 's': { x: 0, y: 1 }, 'ArrowLeft': { x: -1, y: 0 }, 'a': { x: -1, y: 0 }, 'ArrowRight': { x: 1, y: 0 }, 'd': { x: 1, y: 0 } };
                    const dir = keyMap[e.key] || keyMap[e.key.toLowerCase()];
                    if (dir) this.queueInput(dir);
                };
                window.addEventListener('keydown', handleKey);
                this.canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const rect = this.canvas.getBoundingClientRect();
                    const t = e.touches[0];
                    const x = t.clientX - rect.left - rect.width / 2;
                    const y = t.clientY - rect.top - rect.height / 2;
                    this.queueInput(Math.abs(x) > Math.abs(y) ? (x > 0 ? { x: 1, y: 0 } : { x: -1, y: 0 }) : (y > 0 ? { x: 0, y: 1 } : { x: 0, y: -1 }));
                }, { passive: false });
            }

            queueInput(newDir) {
                if (this.inputQueue.length >= 2) return;
                const lastDir = this.inputQueue.length > 0 ? this.inputQueue[this.inputQueue.length - 1] : this.direction;
                if (newDir.x === -lastDir.x && newDir.y === -lastDir.y) return;
                if (newDir.x === lastDir.x && newDir.y === lastDir.y) return;
                this.inputQueue.push(newDir);
            }

            async initGame(name, diffSettings, diffKey, isRevive = false) {
                if (!isRevive) {
                    this.playerName = name;
                    this.difficulty = diffSettings;
                    this.score = 0;
                    this.level = 1;
                    this.coinsCollected = 0;
                    this.items = [];
                    this.snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }];
                    this.direction = { x: 1, y: 0 };
                    this.inputQueue = [];
                    this.adManager.reviveUsed = false; // Reset Ad use
                    document.getElementById('btnWatchAd').style.display = 'block';
                }

                // Remote Config Check
                const config = await this.cloud.fetchConfig();
                if (config) {
                    this.tickRate = config.baseSpeed || diffSettings.speed;
                } else {
                    this.tickRate = diffSettings.speed;
                }

                this.state = 'PLAYING';
                if (!isRevive) {
                    for (let i = 0; i < diffSettings.obst; i++) this.spawnItem('OBSTACLE');
                    this.spawnItem('COIN');
                }
                this.updateHUD();
            }

            spawnItem(type) {
                let pos, attempts = 0;
                do {
                    pos = { x: Math.floor(Math.random() * CONFIG.GRID_SIZE), y: Math.floor(Math.random() * CONFIG.GRID_SIZE) };
                    attempts++;
                } while (this.checkCollision(pos) && attempts < 50);
                if (attempts < 50) this.items.push({ ...pos, type, id: Math.random() });
            }

            checkCollision(pos, ignoreHead = false) {
                for (let i = ignoreHead ? 1 : 0; i < this.snake.length; i++) if (this.snake[i].x === pos.x && this.snake[i].y === pos.y) return 'BODY';
                for (let item of this.items) if (item.x === pos.x && item.y === pos.y) return item.type;
                return null;
            }

            update(dt) {
                this.particles.update();
                if (this.state !== 'PLAYING') return;
                this.accumTime += dt;
                if (this.accumTime >= this.tickRate) {
                    this.accumTime -= this.tickRate;
                    this.step();
                }
            }

            step() {
                if (this.inputQueue.length > 0) this.direction = this.inputQueue.shift();
                const head = { ...this.snake[0] };
                head.x += this.direction.x; head.y += this.direction.y;
                if (head.x >= CONFIG.GRID_SIZE) head.x = 0; else if (head.x < 0) head.x = CONFIG.GRID_SIZE - 1;
                if (head.y >= CONFIG.GRID_SIZE) head.y = 0; else if (head.y < 0) head.y = CONFIG.GRID_SIZE - 1;

                const collision = this.checkCollision(head, true);
                if (collision === 'BODY' || collision === 'OBSTACLE') { this.gameOver(); return; }

                this.snake.unshift(head);
                const itemIdx = this.items.findIndex(i => i.x === head.x && i.y === head.y);
                let grew = false;

                if (itemIdx !== -1) {
                    const item = this.items[itemIdx];
                    if (item.type === 'COIN') {
                        this.score += 10 * this.difficulty.mult;
                        this.coinsCollected++;
                        this.audio.playTone('sine', 800, 1200, 0.15);
                        this.particles.emit(head.x * this.cellSize + this.cellSize / 2, head.y * this.cellSize + this.cellSize / 2, CONFIG.COLORS.COIN);
                        this.items.splice(itemIdx, 1);
                        this.spawnItem('COIN');
                        if (Math.random() < 0.1) this.spawnItem('DIAMOND');
                        if (this.coinsCollected % 5 === 0) this.levelUp();
                        grew = true;
                    } else if (item.type === 'DIAMOND') {
                        this.score += 50 * this.difficulty.mult;
                        this.audio.playTone('triangle', 600, 600, 0.2);
                        this.particles.emit(head.x * this.cellSize + this.cellSize / 2, head.y * this.cellSize + this.cellSize / 2, CONFIG.COLORS.DIAMOND, 20);
                        this.items.splice(itemIdx, 1);
                    } else if (item.type === 'OBSTACLE') { this.gameOver(); return; }
                }
                if (!grew) this.snake.pop();
                this.updateHUD();
            }

            levelUp() {
                this.level++;
                this.tickRate *= 0.9;
                this.audio.playLevelUp();
                this.spawnItem('OBSTACLE');
                const notif = document.getElementById('notification-overlay');
                notif.innerText = `LEVEL ${this.level}`;
                notif.classList.remove('active');
                void notif.offsetWidth;
                notif.classList.add('active');
            }

            gameOver() {
                this.state = 'OVER';
                this.audio.playNoise(0.5);
                this.canvas.style.transform = `translate(${Math.random() * 10 - 5}px, ${Math.random() * 10 - 5}px)`;
                setTimeout(() => this.canvas.style.transform = 'none', 400);
                this.cloud.saveScore(this.playerName, this.score, this.level);
                showGameOver(this.score);
            }

            draw() {
                this.ctx.fillStyle = CONFIG.COLORS.GRID;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.strokeStyle = '#1a1a1a';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                for (let i = 0; i <= CONFIG.GRID_SIZE; i++) {
                    this.ctx.moveTo(i * this.cellSize, 0); this.ctx.lineTo(i * this.cellSize, this.canvas.height);
                    this.ctx.moveTo(0, i * this.cellSize); this.ctx.lineTo(this.canvas.width, i * this.cellSize);
                }
                this.ctx.stroke();

                this.items.forEach(item => {
                    const cx = item.x * this.cellSize + this.cellSize / 2;
                    const cy = item.y * this.cellSize + this.cellSize / 2;
                    this.ctx.shadowBlur = 20;
                    if (item.type === 'COIN') {
                        this.ctx.fillStyle = CONFIG.COLORS.COIN; this.ctx.shadowColor = CONFIG.COLORS.COIN;
                        this.ctx.beginPath(); this.ctx.arc(cx, cy, this.cellSize / 3, 0, Math.PI * 2); this.ctx.fill();
                    } else if (item.type === 'OBSTACLE') {
                        this.ctx.fillStyle = CONFIG.COLORS.OBSTACLE; this.ctx.shadowColor = CONFIG.COLORS.OBSTACLE;
                        this.ctx.fillRect(item.x * this.cellSize + 2, item.y * this.cellSize + 2, this.cellSize - 4, this.cellSize - 4);
                    } else if (item.type === 'DIAMOND') {
                        this.ctx.fillStyle = CONFIG.COLORS.DIAMOND; this.ctx.shadowColor = CONFIG.COLORS.DIAMOND;
                        this.ctx.beginPath(); this.ctx.moveTo(cx, cy - this.cellSize / 2.5); this.ctx.lineTo(cx + this.cellSize / 2.5, cy); this.ctx.lineTo(cx, cy + this.cellSize / 2.5); this.ctx.lineTo(cx - this.cellSize / 2.5, cy); this.ctx.fill();
                    }
                });

                this.snake.forEach((seg, i) => {
                    const x = seg.x * this.cellSize;
                    const y = seg.y * this.cellSize;
                    this.ctx.shadowBlur = 10;
                    this.ctx.fillStyle = i === 0 ? CONFIG.COLORS.HEAD : (i % 2 === 0 ? CONFIG.COLORS.BODY_START : CONFIG.COLORS.BODY_END);
                    this.ctx.shadowColor = this.ctx.fillStyle;
                    this.ctx.beginPath(); this.ctx.roundRect(x + 1, y + 1, this.cellSize - 2, this.cellSize - 2, 4); this.ctx.fill();
                    if (i === 0) {
                        this.ctx.fillStyle = 'black'; this.ctx.shadowBlur = 0;
                        this.ctx.beginPath(); this.ctx.arc(x + this.cellSize * 0.3, y + this.cellSize * 0.3, 2, 0, Math.PI * 2); this.ctx.fill();
                        this.ctx.beginPath(); this.ctx.arc(x + this.cellSize * 0.7, y + this.cellSize * 0.3, 2, 0, Math.PI * 2); this.ctx.fill();
                    }
                });
                this.ctx.shadowBlur = 0;
                this.particles.draw();
            }

            updateHUD() {
                document.getElementById('scoreVal').innerText = Math.floor(this.score);
                document.getElementById('levelVal').innerText = this.level;
            }

            loop(timestamp) {
                const dt = timestamp - this.lastTime;
                this.lastTime = timestamp;
                this.update(dt);
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }
        }

        // --- SCORE SYSTEM ---
        function saveLocalScore(name, score, level) {
            let lb = JSON.parse(localStorage.getItem('neonSnakeLeaderboard') || '[]');
            lb.push({ name, score, level, date: Date.now() });
            lb.sort((a, b) => b.score - a.score);
            lb = lb.slice(0, 10);
            localStorage.setItem('neonSnakeLeaderboard', JSON.stringify(lb));
        }

        function getLocalLeaderboard() { return JSON.parse(localStorage.getItem('neonSnakeLeaderboard') || '[]'); }

        // --- DOM & UI ---
        const dom = {
            start: document.getElementById('start-screen'),
            game: document.getElementById('game-container'),
            over: document.getElementById('game-over-screen'),
            nameInput: document.getElementById('playerNameInput'),
            cards: document.querySelectorAll('.card'),
            btnStart: document.getElementById('btnStart'),
            btnRestart: document.getElementById('btnRestart'),
            btnMenu: document.getElementById('btnMenu'),
            table: document.querySelector('#leaderboardTable tbody'),
            btnLogin: document.getElementById('btnLogin'),
            lbToggle: document.getElementById('lbToggle'),
            lbTitle: document.getElementById('lbTitle'),
            btnWatchAd: document.getElementById('btnWatchAd')
        };

        let selectedDiff = null;
        let viewGlobalLB = false;

        dom.cards.forEach(c => {
            c.addEventListener('click', () => {
                dom.cards.forEach(card => card.classList.remove('selected'));
                c.classList.add('selected');
                selectedDiff = c.dataset.diff;
                checkStartReady();
            });
        });

        dom.nameInput.addEventListener('input', checkStartReady);

        function checkStartReady() {
            if (dom.nameInput.value.trim().length > 0 && selectedDiff) {
                dom.btnStart.classList.add('active');
            } else {
                dom.btnStart.classList.remove('active');
            }
        }

        function updateProfileUI(user) {
            if (user) {
                document.getElementById('user-profile').classList.add('visible');
                document.getElementById('user-name').innerText = user.displayName;
                document.getElementById('user-avatar').src = user.photoURL;
                dom.nameInput.value = user.displayName; // Auto-fill name
                dom.btnLogin.style.display = 'none'; // Hide login button
                checkStartReady();
            }
        }

        dom.btnLogin.addEventListener('click', () => game.cloud.signIn());

        dom.btnStart.addEventListener('click', () => {
            if (!dom.btnStart.classList.contains('active')) return;
            dom.start.classList.add('hidden');
            const diff = CONFIG.DIFFICULTY[selectedDiff];
            game.initGame(dom.nameInput.value.trim(), diff, selectedDiff);
        });

        dom.btnRestart.addEventListener('click', () => {
            dom.over.classList.add('hidden');
            game.initGame(game.playerName, game.difficulty, selectedDiff);
        });

        dom.btnMenu.addEventListener('click', () => {
            dom.over.classList.add('hidden');
            dom.start.classList.remove('hidden');
        });

        dom.btnWatchAd.addEventListener('click', () => {
            game.adManager.showRewardedAd(() => {
                dom.over.classList.add('hidden');
                game.state = 'PLAYING'; // Resume
                // Grant immunity briefly to prevent instant death? 
                // For simplicity, we just resume. In a real game, we'd clear local obstacles.
            });
        });

        dom.lbToggle.addEventListener('click', async () => {
            viewGlobalLB = !viewGlobalLB;
            dom.lbTitle.innerText = viewGlobalLB ? "GLOBAL LEGENDS" : "LOCAL LEGENDS";
            dom.lbToggle.innerText = viewGlobalLB ? "Switch to Local üè†" : "Switch to Global üåê";
            refreshLeaderboard();
        });

        async function refreshLeaderboard(score = 0) {
            let lb = [];
            if (viewGlobalLB) {
                dom.table.innerHTML = '<tr><td colspan="4">Loading Cloud Data...</td></tr>';
                lb = await game.cloud.getGlobalLeaderboard();
                if (lb.length === 0) lb = [{ name: "No Cloud Data", score: 0, level: 0 }];
            } else {
                lb = getLocalLeaderboard();
            }

            dom.table.innerHTML = lb.map((entry, i) => `
        <tr class="${entry.score === score && entry.name === game.playerName ? 'highlight-row' : ''}">
            <td>${i + 1}</td>
            <td>${entry.name}</td>
            <td>${Math.floor(entry.score)}</td>
            <td>${entry.level}</td>
        </tr>
    `).join('');
        }

        function showGameOver(score) {
            dom.over.classList.remove('hidden');
            document.getElementById('finalScore').innerText = Math.floor(score);
            // Show Ad Button if not used
            dom.btnWatchAd.style.display = game.adManager.canWatchAd() ? 'flex' : 'none';
            refreshLeaderboard(score);
        }

        // Init
        const game = new Game();
    </script>
</body>

</html>